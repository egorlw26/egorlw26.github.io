(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var canvas = document.createElement('canvas')
document.body.appendChild(canvas)

canvas.width = window.innerWidth*0.95;
canvas.height = window.innerHeight*0.95;
canvas.style = "position: center;"
var offsetForMaze = 1;

var context = canvas.getContext('2d')

/// set parameters
var rows = 15;
var columns = 15;
var w = canvas.width / rows-1;
var h = canvas.height / columns-1;

//simple way to draw line
function draw_line(startX, startY, endX, endY){
  context.beginPath();
  context.moveTo(startX, startY);
  context.lineTo(endX, endY);
  context.stroke();
}

function randomInt(a, b) {
  return Math.floor(a + Math.random() * (b - a));
}

function randomChoice(list) {
  const id = randomInt(0, list.length);
  return list[id];
}

const Dirs = [
  [-1, 0],
  [0, 1],
  [1, 0],
  [0, -1]
];

class Cell {
  constructor(type = 0) {
    this.type = type;
    this.walls = [true, true, true, true];
  }

  draw(x, y) {
    context.strokeStyle = 'black'
    for (let i = 0; i < 4; ++i) {
      const next_x = x + Dirs[(i + 1) % 4][0];
      const next_y = y + Dirs[(i + 1) % 4][1];
      if (this.walls[i]) {
        draw_line(offsetForMaze + x * w, offsetForMaze + y * h,
          offsetForMaze + next_x * w, offsetForMaze + next_y * h);
      }
      x = next_x;
      y = next_y;
    }
  }
}

class Maze {
  constructor(width, height) {
    this.width = width
    this.height = height
    this.initGrid()
  }

  initGrid() {
    this.maze = [];
    for (let y = 0; y < this.height; ++y) {
      var row = [];
      for (let x = 0; x < this.width; ++x)
        row.push(new Cell(0));
      this.maze.push(row);
    }
  }

  isInGrid(x, y) {
    return (x >= 0 && y >= 0 && x < this.width && y < this.height);
  }

  dfsGenerator() {
    var visited = [];
    for (let y = 0; y < this.height; ++y) {
      var row = [];
      for (let x = 0; x < this.width; ++x)
        row.push(false);
      visited.push(row);
    }
    var stack = [
      [randomInt(0, this.width), randomInt(0, this.height)]
    ];
    while (stack.length > 0) {
      const curr_pos = stack[stack.length - 1];
      const x = curr_pos[0];
      const y = curr_pos[1];
      visited[y][x] = true;
      var available_dirs = [];
      for (let i = 0; i < 4; ++i) {
        const cell_x = x + Dirs[i][0];
        const cell_y = y + Dirs[i][1];
        if (this.isInGrid(cell_x, cell_y) && !visited[cell_y][cell_x])
          available_dirs.push(i);
      }
      if (available_dirs.length == 0) {
        stack.pop();
        continue;
      }
      const dir_id = randomChoice(available_dirs);
      const next_x = x + Dirs[dir_id][0];
      const next_y = y + Dirs[dir_id][1];
      stack.push([next_x, next_y]);
      this.maze[y][x].walls[dir_id] = false;
      this.maze[next_y][next_x].walls[(dir_id + 2) % 4] = false;
    }
  }

  draw() {
    context.rect(0, 0, this.width * 20, this.height * 20);
    for (let y = 0; y < this.height; ++y)
      for (let x = 0; x < this.width; ++x)
        this.maze[y][x].draw(x, y);
  }
}

class Player{
  constructor(maze){
    this.path = [];
    this.found = false;
    this.visited = [];
    this.maze = maze;
  }
  dfsPathfinderStart(){
    this.found = false;
    this.visited = [];
    for(var i = 0; i<rows; i++){
      var row = [];
      for(var j = 0; j<columns; j++)
        row.push(false);
      this.visited.push(row);
    }

    this.path =[
      [Math.floor(rows/2) - 1, Math.floor(columns/2) - 1]
    ];
  }

  dfsPathfinderMakeStep(targetX, targetY) {
      if(this.path.length > 0 && !this.found) {
      const curr_pos = this.path[this.path.length -1];
      const x = curr_pos[0];
      const y = curr_pos[1];
      this.visited[y][x] = true;

      /// We found our target!
      if(x === targetX && y === targetY){
        this.found = true;
        return;
      }

      var available_dirs = []
      for(var i = 0; i<4; i++){
        const cell_x = x + Dirs[i][0];
        const cell_y = y + Dirs[i][1];
        if(this.maze.isInGrid(cell_x, cell_y) && !this.visited[cell_y][cell_x] && !this.maze.maze[y][x].walls[i])
          available_dirs.push(i);
      }

      if (available_dirs.length == 0) {
        this.path.pop();
        return;
      }

      const dir_id = available_dirs[0];
      const next_x = x + Dirs[dir_id][0];
      const next_y = y + Dirs[dir_id][1];
      this.path.push([next_x, next_y]);
    }
  }
}

function drawPlayerPath(path){
  context.strokeStyle = 'red';
  for(var i = 1; i<path.length; i++)
  draw_line(path[i-1][0]*w + w/2, path[i-1][1]*h + h/2, 
    path[i][0]*w + w/2, path[i][1]*h + h/2);
}

function drawEverything(maze, player){
  maze.draw();
  drawPlayerPath(player.path);
}

var maze = new Maze(rows, columns);
maze.dfsGenerator();

var player = new Player(maze);
player.dfsPathfinderStart();


function update(){
  context.clearRect(0, 0, canvas.width, canvas.height);
  player.dfsPathfinderMakeStep(0, 0);
  drawEverything(maze, player);
  setTimeout(update, 40);
}

update();
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJ2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpXHJcblxyXG5jYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCowLjk1O1xyXG5jYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0KjAuOTU7XHJcbmNhbnZhcy5zdHlsZSA9IFwicG9zaXRpb246IGNlbnRlcjtcIlxyXG52YXIgb2Zmc2V0Rm9yTWF6ZSA9IDE7XHJcblxyXG52YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXHJcblxyXG4vLy8gc2V0IHBhcmFtZXRlcnNcclxudmFyIHJvd3MgPSAxNTtcclxudmFyIGNvbHVtbnMgPSAxNTtcclxudmFyIHcgPSBjYW52YXMud2lkdGggLyByb3dzLTE7XHJcbnZhciBoID0gY2FudmFzLmhlaWdodCAvIGNvbHVtbnMtMTtcclxuXHJcbi8vc2ltcGxlIHdheSB0byBkcmF3IGxpbmVcclxuZnVuY3Rpb24gZHJhd19saW5lKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZKXtcclxuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gIGNvbnRleHQubW92ZVRvKHN0YXJ0WCwgc3RhcnRZKTtcclxuICBjb250ZXh0LmxpbmVUbyhlbmRYLCBlbmRZKTtcclxuICBjb250ZXh0LnN0cm9rZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByYW5kb21JbnQoYSwgYikge1xyXG4gIHJldHVybiBNYXRoLmZsb29yKGEgKyBNYXRoLnJhbmRvbSgpICogKGIgLSBhKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhbmRvbUNob2ljZShsaXN0KSB7XHJcbiAgY29uc3QgaWQgPSByYW5kb21JbnQoMCwgbGlzdC5sZW5ndGgpO1xyXG4gIHJldHVybiBsaXN0W2lkXTtcclxufVxyXG5cclxuY29uc3QgRGlycyA9IFtcclxuICBbLTEsIDBdLFxyXG4gIFswLCAxXSxcclxuICBbMSwgMF0sXHJcbiAgWzAsIC0xXVxyXG5dO1xyXG5cclxuY2xhc3MgQ2VsbCB7XHJcbiAgY29uc3RydWN0b3IodHlwZSA9IDApIHtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLndhbGxzID0gW3RydWUsIHRydWUsIHRydWUsIHRydWVdO1xyXG4gIH1cclxuXHJcbiAgZHJhdyh4LCB5KSB7XHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsYWNrJ1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgICAgY29uc3QgbmV4dF94ID0geCArIERpcnNbKGkgKyAxKSAlIDRdWzBdO1xyXG4gICAgICBjb25zdCBuZXh0X3kgPSB5ICsgRGlyc1soaSArIDEpICUgNF1bMV07XHJcbiAgICAgIGlmICh0aGlzLndhbGxzW2ldKSB7XHJcbiAgICAgICAgZHJhd19saW5lKG9mZnNldEZvck1hemUgKyB4ICogdywgb2Zmc2V0Rm9yTWF6ZSArIHkgKiBoLFxyXG4gICAgICAgICAgb2Zmc2V0Rm9yTWF6ZSArIG5leHRfeCAqIHcsIG9mZnNldEZvck1hemUgKyBuZXh0X3kgKiBoKTtcclxuICAgICAgfVxyXG4gICAgICB4ID0gbmV4dF94O1xyXG4gICAgICB5ID0gbmV4dF95O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgTWF6ZSB7XHJcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoXHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxyXG4gICAgdGhpcy5pbml0R3JpZCgpXHJcbiAgfVxyXG5cclxuICBpbml0R3JpZCgpIHtcclxuICAgIHRoaXMubWF6ZSA9IFtdO1xyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgKyt5KSB7XHJcbiAgICAgIHZhciByb3cgPSBbXTtcclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyArK3gpXHJcbiAgICAgICAgcm93LnB1c2gobmV3IENlbGwoMCkpO1xyXG4gICAgICB0aGlzLm1hemUucHVzaChyb3cpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaXNJbkdyaWQoeCwgeSkge1xyXG4gICAgcmV0dXJuICh4ID49IDAgJiYgeSA+PSAwICYmIHggPCB0aGlzLndpZHRoICYmIHkgPCB0aGlzLmhlaWdodCk7XHJcbiAgfVxyXG5cclxuICBkZnNHZW5lcmF0b3IoKSB7XHJcbiAgICB2YXIgdmlzaXRlZCA9IFtdO1xyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgKyt5KSB7XHJcbiAgICAgIHZhciByb3cgPSBbXTtcclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyArK3gpXHJcbiAgICAgICAgcm93LnB1c2goZmFsc2UpO1xyXG4gICAgICB2aXNpdGVkLnB1c2gocm93KTtcclxuICAgIH1cclxuICAgIHZhciBzdGFjayA9IFtcclxuICAgICAgW3JhbmRvbUludCgwLCB0aGlzLndpZHRoKSwgcmFuZG9tSW50KDAsIHRoaXMuaGVpZ2h0KV1cclxuICAgIF07XHJcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBjdXJyX3BvcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICBjb25zdCB4ID0gY3Vycl9wb3NbMF07XHJcbiAgICAgIGNvbnN0IHkgPSBjdXJyX3Bvc1sxXTtcclxuICAgICAgdmlzaXRlZFt5XVt4XSA9IHRydWU7XHJcbiAgICAgIHZhciBhdmFpbGFibGVfZGlycyA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IGNlbGxfeCA9IHggKyBEaXJzW2ldWzBdO1xyXG4gICAgICAgIGNvbnN0IGNlbGxfeSA9IHkgKyBEaXJzW2ldWzFdO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5HcmlkKGNlbGxfeCwgY2VsbF95KSAmJiAhdmlzaXRlZFtjZWxsX3ldW2NlbGxfeF0pXHJcbiAgICAgICAgICBhdmFpbGFibGVfZGlycy5wdXNoKGkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdmFpbGFibGVfZGlycy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRpcl9pZCA9IHJhbmRvbUNob2ljZShhdmFpbGFibGVfZGlycyk7XHJcbiAgICAgIGNvbnN0IG5leHRfeCA9IHggKyBEaXJzW2Rpcl9pZF1bMF07XHJcbiAgICAgIGNvbnN0IG5leHRfeSA9IHkgKyBEaXJzW2Rpcl9pZF1bMV07XHJcbiAgICAgIHN0YWNrLnB1c2goW25leHRfeCwgbmV4dF95XSk7XHJcbiAgICAgIHRoaXMubWF6ZVt5XVt4XS53YWxsc1tkaXJfaWRdID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubWF6ZVtuZXh0X3ldW25leHRfeF0ud2FsbHNbKGRpcl9pZCArIDIpICUgNF0gPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRyYXcoKSB7XHJcbiAgICBjb250ZXh0LnJlY3QoMCwgMCwgdGhpcy53aWR0aCAqIDIwLCB0aGlzLmhlaWdodCAqIDIwKTtcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7ICsreSlcclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyArK3gpXHJcbiAgICAgICAgdGhpcy5tYXplW3ldW3hdLmRyYXcoeCwgeSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBQbGF5ZXJ7XHJcbiAgY29uc3RydWN0b3IobWF6ZSl7XHJcbiAgICB0aGlzLnBhdGggPSBbXTtcclxuICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcclxuICAgIHRoaXMudmlzaXRlZCA9IFtdO1xyXG4gICAgdGhpcy5tYXplID0gbWF6ZTtcclxuICB9XHJcbiAgZGZzUGF0aGZpbmRlclN0YXJ0KCl7XHJcbiAgICB0aGlzLmZvdW5kID0gZmFsc2U7XHJcbiAgICB0aGlzLnZpc2l0ZWQgPSBbXTtcclxuICAgIGZvcih2YXIgaSA9IDA7IGk8cm93czsgaSsrKXtcclxuICAgICAgdmFyIHJvdyA9IFtdO1xyXG4gICAgICBmb3IodmFyIGogPSAwOyBqPGNvbHVtbnM7IGorKylcclxuICAgICAgICByb3cucHVzaChmYWxzZSk7XHJcbiAgICAgIHRoaXMudmlzaXRlZC5wdXNoKHJvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wYXRoID1bXHJcbiAgICAgIFtNYXRoLmZsb29yKHJvd3MvMikgLSAxLCBNYXRoLmZsb29yKGNvbHVtbnMvMikgLSAxXVxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIGRmc1BhdGhmaW5kZXJNYWtlU3RlcCh0YXJnZXRYLCB0YXJnZXRZKSB7XHJcbiAgICAgIGlmKHRoaXMucGF0aC5sZW5ndGggPiAwICYmICF0aGlzLmZvdW5kKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJfcG9zID0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLTFdO1xyXG4gICAgICBjb25zdCB4ID0gY3Vycl9wb3NbMF07XHJcbiAgICAgIGNvbnN0IHkgPSBjdXJyX3Bvc1sxXTtcclxuICAgICAgdGhpcy52aXNpdGVkW3ldW3hdID0gdHJ1ZTtcclxuXHJcbiAgICAgIC8vLyBXZSBmb3VuZCBvdXIgdGFyZ2V0IVxyXG4gICAgICBpZih4ID09PSB0YXJnZXRYICYmIHkgPT09IHRhcmdldFkpe1xyXG4gICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGF2YWlsYWJsZV9kaXJzID0gW11cclxuICAgICAgZm9yKHZhciBpID0gMDsgaTw0OyBpKyspe1xyXG4gICAgICAgIGNvbnN0IGNlbGxfeCA9IHggKyBEaXJzW2ldWzBdO1xyXG4gICAgICAgIGNvbnN0IGNlbGxfeSA9IHkgKyBEaXJzW2ldWzFdO1xyXG4gICAgICAgIGlmKHRoaXMubWF6ZS5pc0luR3JpZChjZWxsX3gsIGNlbGxfeSkgJiYgIXRoaXMudmlzaXRlZFtjZWxsX3ldW2NlbGxfeF0gJiYgIXRoaXMubWF6ZS5tYXplW3ldW3hdLndhbGxzW2ldKVxyXG4gICAgICAgICAgYXZhaWxhYmxlX2RpcnMucHVzaChpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGF2YWlsYWJsZV9kaXJzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoLnBvcCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGlyX2lkID0gYXZhaWxhYmxlX2RpcnNbMF07XHJcbiAgICAgIGNvbnN0IG5leHRfeCA9IHggKyBEaXJzW2Rpcl9pZF1bMF07XHJcbiAgICAgIGNvbnN0IG5leHRfeSA9IHkgKyBEaXJzW2Rpcl9pZF1bMV07XHJcbiAgICAgIHRoaXMucGF0aC5wdXNoKFtuZXh0X3gsIG5leHRfeV0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd1BsYXllclBhdGgocGF0aCl7XHJcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZWQnO1xyXG4gIGZvcih2YXIgaSA9IDE7IGk8cGF0aC5sZW5ndGg7IGkrKylcclxuICBkcmF3X2xpbmUocGF0aFtpLTFdWzBdKncgKyB3LzIsIHBhdGhbaS0xXVsxXSpoICsgaC8yLCBcclxuICAgIHBhdGhbaV1bMF0qdyArIHcvMiwgcGF0aFtpXVsxXSpoICsgaC8yKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd0V2ZXJ5dGhpbmcobWF6ZSwgcGxheWVyKXtcclxuICBtYXplLmRyYXcoKTtcclxuICBkcmF3UGxheWVyUGF0aChwbGF5ZXIucGF0aCk7XHJcbn1cclxuXHJcbnZhciBtYXplID0gbmV3IE1hemUocm93cywgY29sdW1ucyk7XHJcbm1hemUuZGZzR2VuZXJhdG9yKCk7XHJcblxyXG52YXIgcGxheWVyID0gbmV3IFBsYXllcihtYXplKTtcclxucGxheWVyLmRmc1BhdGhmaW5kZXJTdGFydCgpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZSgpe1xyXG4gIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgcGxheWVyLmRmc1BhdGhmaW5kZXJNYWtlU3RlcCgwLCAwKTtcclxuICBkcmF3RXZlcnl0aGluZyhtYXplLCBwbGF5ZXIpO1xyXG4gIHNldFRpbWVvdXQodXBkYXRlLCA0MCk7XHJcbn1cclxuXHJcbnVwZGF0ZSgpOyJdfQ==
